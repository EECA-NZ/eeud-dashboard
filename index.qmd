--- 
title: "EEUD Dashboard"
logo: "https://eecagovtnz.sharepoint.com/SiteAssets/__rectSitelogo__Only%20EECA%20white.png"
format: 
  dashboard:
    theme: "eeca.scss"
    expandable: false
server: shiny
---

```{python}
import re
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from shiny import render, reactive, ui
from shinywidgets import render_widget, render_plotly
from faicons import icon_svg

#import logging
#logger = logging.getLogger()
#logging.basicConfig(level=logging.INFO)
#logger.info('Custom Log Message.')

eeud = pd.read_csv('./data/EEUD-03042024.csv')
eeud['PeriodEndDate'] = pd.to_datetime(eeud['PeriodEndDate'])
eeud_colours = pd.read_csv('./data/eeud_colours.csv', index_col=0, header=0).squeeze("columns")

sector_groups_list = list(eeud['SectorGroup'].sort_values().unique())
sectors_list = list(eeud['Sector'].sort_values().unique())
fuels_list = list(eeud['Fuel'].sort_values().unique())
technology_groups_list = list(eeud['TechnologyGroup'].sort_values().unique())
technologies_list = list(eeud['Technology'].sort_values().unique())
years_list = list(eeud['Period'].sort_values(ascending=False).unique())
end_uses_list = list(eeud['EndUse'].sort_values().unique())
sector_groups = {group: set(sub_df['Sector'].dropna()) for group, sub_df in eeud.groupby('SectorGroup')}

```

```{python}
#| include: false
def title_case(s):
    return re.sub(r"(_|-)+", " ", s).title().replace(" ", "")

def hex_to_rgba(hex, alpha=1):
    hex = hex.replace('#','')
    return f"rgba{tuple([int(hex[i:i+2], 16) for i in (0, 2, 4)] + [alpha])}"

def create_sankey_links_for_dict(df, *columns):
    """
    Creates a dictionary suitable for generating Sankey diagram links with indices corresponding to labels.
    
    Parameters:
    - df: pandas DataFrame containing the base data.
    - columns: variable number of arguments, each a string representing a column name
      in df that corresponds to a node in the Sankey diagram.
    
    Returns:
    - A dictionary with 'source', 'target', and 'value' keys ready to be used as input for a Sankey diagram.
    - A list of unique labels corresponding to all nodes in the Sankey diagram.
    """
    links_list = []
    labels = []
    
    for i in range(len(columns)-1):
        # For each pair of columns, create source-target pairs
        temp_df = df.groupby([columns[i], columns[i+1]])['TJ'].sum().reset_index()
        temp_df['source'] = temp_df[columns[i]].astype(str)
        temp_df['target'] = temp_df[columns[i+1]].astype(str)
        links_list.append(temp_df)
        labels.extend(temp_df['source'].tolist())
        labels.extend(temp_df['target'].tolist())
    
    # Remove duplicate labels and sort
    labels = sorted(set(labels))
    
    # Create the final links DataFrame
    links_df = pd.concat(links_list, ignore_index=True)
    
    # Map 'source' and 'target' to their indices in the labels list
    links_df['source'] = links_df['source'].apply(lambda x: labels.index(x))
    links_df['target'] = links_df['target'].apply(lambda x: labels.index(x))
    
    # Aggregate and sum 'value' for each unique source-target pair
    links_df = links_df.groupby(['source', 'target'], as_index=False)['TJ'].sum()
    
    # Format for Sankey diagram
    link_dict = {
        'source': links_df['source'].tolist(),
        'target': links_df['target'].tolist(),
        'value': links_df['TJ'].tolist(),
        'color': links_df['source'].apply(lambda s: hex_to_rgba(eeud_colours[labels[s].split('_')[0]] if labels[s].split('_')[0] in eeud_colours else "#000000", 2/3)).tolist()
    }

    nodes_dict = {
        'label': labels,
        'color': list(map(lambda l: hex_to_rgba(eeud_colours[l.split('_')[0]] if l.split('_')[0] in eeud_colours else "#000000", 1), labels))
    }

    return link_dict, nodes_dict

def create_alluvial_links_for_dict(df, category_column, date_column, date_freq='Y'):
    """
    Creates dictionaries suitable for generating an alluvial diagram with indices corresponding to labels,
    mapping the 'TJ' of each category across continuous values of another column (date column).
    
    Parameters:
    - df: pandas DataFrame containing the base data.
    - category_column: string representing the column name in df that corresponds to categories.
    - date_column: string representing the date column in df for mapping across time.
    - date_freq: string specifying the frequency to aggregate dates (e.g., 'Y' for year, 'M' for month).
    
    Returns:
    - A dictionary with 'source', 'target', and 'value' keys ready to be used as input for a Sankey diagram.
    - A list of unique labels corresponding to all nodes in the Sankey diagram.
    """
    # Convert the date column to the specified frequency period
    df = df.copy()
    df[date_column] = df[date_column].dt.to_period(date_freq)
    
    # Group by category and date period, then sum the TJ
    grouped_df = df.groupby([category_column, date_column])['TJ'].sum().reset_index()
    
    # Create source and target columns by shifting the date period to link successive periods
    grouped_df['source'] = grouped_df.apply(lambda x: f"{x[category_column]}_{x[date_column]}", axis=1)
    grouped_df['target'] = grouped_df.apply(lambda x: f"{x[category_column]}_{x[date_column] + 1}", axis=1)
    
    # Generate labels from source and target columns
    labels = sorted(set(grouped_df['source'].tolist() + grouped_df['target'].tolist()))
    
    # Map 'source' and 'target' to their indices in the labels list
    grouped_df['source'] = grouped_df['source'].apply(lambda x: labels.index(x))
    grouped_df['target'] = grouped_df['target'].apply(lambda x: labels.index(x))
    
    # Prepare the link and nodes dictionaries
    link_dict = {
        'source': grouped_df['source'].tolist()[:-1], # Exclude the last mapping as it has no next period
        'target': grouped_df['target'].tolist()[:-1],
        'value': grouped_df['TJ'].tolist()[:-1],
        'color': grouped_df['source'].apply(lambda s: hex_to_rgba(eeud_colours[labels[s].split('_')[0]] if labels[s].split('_')[0] in eeud_colours else "#000000", 2/3)).tolist()
    }

    nodes_dict = {
        'label': list(map(lambda l: l.replace('_', ' '), labels)),
        'color': list(map(lambda l: hex_to_rgba(eeud_colours[l.split('_')[0]] if l.split('_')[0] in eeud_colours else "#000000", 1), labels))
    }

    return link_dict, nodes_dict

```


# Overview

## Row

### Column {width=30%}

#### Row

```{python}
#| content: valuebox
#| title: "Title"
dict(
    icon = "asterisk",
    color = "primary",
    value = "Value"
)
```

#### Row

```{python}
#| content: valuebox
#| title: "Title"
dict(
    icon = "asterisk",
    color = "secondary",
    value = "Value"
)
```

```{python}
#| content: valuebox
#| title: "Title"
dict(
    icon = "asterisk",
    color = "secondary",
    value = "Value"
)
```

```{python}
#| content: valuebox
#| title: "Title"
dict(
    icon = "asterisk",
    color = "secondary",
    value = "Value"
)
```


### Column {width=40%}

```{python}
#| title: "Chart"
"Chart goes here!"
```

### Column {width=30%}

#### Row

```{python}
#| content: valuebox
#| title: "Title"
dict(
    icon = "asterisk",
    color = "primary",
    value = "Value"
)
```

#### Row

```{python}
#| content: valuebox
#| title: "Title"
dict(
    icon = "asterisk",
    color = "secondary",
    value = "Value"
)
```

```{python}
#| content: valuebox
#| title: "Title"
dict(
    icon = "asterisk",
    color = "secondary",
    value = "Value"
)
```

```{python}
#| content: valuebox
#| title: "Title"
dict(
    icon = "asterisk",
    color = "secondary",
    value = "Value"
)
```


## Row

```{python}
#| content: card-toolbar
ui.input_select("treemap_category", "Category", choices=["Fuel", "Technology", "End Use", "Sector"], selected="Sector")
```

```{python}
#| title: Treemap
"Chart goes here!"

```


# Explore

## Row

### Column {.sidebar}

<h5>Categories</h5>

```{python}
ui.input_select("explore_left_node", "Left", choices=["End Use", "End Use Group", "Fuel", "Fuel Group", "Sector", "Sector Group", "Technology", "Technology Group"], selected="Fuel")
ui.input_select("explore_right_node", "Right", choices=["End Use", "End Use Group", "Fuel", "Fuel Group", "Sector", "Sector Group", "Technology", "Technology Group"], selected="End Use Group")
```

<br/>
<h5>Filter</h5>

```{python}
sectors_dict = {'Residential': ['All Residential', 'Residential', 'Residential Unallocated'],
    'Industrial': ['All Industrial', 'Construction', 'Dairy', 'Manufacturing']}

ui.input_selectize('explore_sectors', "Sector", sectors_list, multiple=True,
    options={
        'placeholder': "All Sectors",
        'plugins': ['clear_button']
    }
)

ui.input_selectize('explore_fuels', "Fuel Type", fuels_list, multiple=True, 
    options={
        'placeholder': "All Fuel Types",
        'plugins': ['clear_button']
    }
)

ui.input_selectize('explore_technologies', "Technology", technologies_list, multiple=True,
    options={
        'placeholder': "All Technologies",
        'plugins': ['clear_button']
    }
) 

ui.input_selectize('explore_end_use', "End Use", end_uses_list, multiple=True,
    options={
        'placeholder': "All End Uses",
        'plugins': ['clear_button']
    }
)

ui.input_slider('explore_period', "Date Range", min=min(years_list), max=max(years_list),
    drag_range=False, value=max(years_list), sep='')


@reactive.Calc
def explore_eeud_filtered():
    data = eeud.copy()

    if len(input.explore_sectors()) > 0:
        data = data[data['Sector'].isin(input.explore_sectors())]

    if len(input.explore_fuels()) > 0:
        data = data[data['Fuel'].isin(input.explore_fuels())]

    if len(input.explore_technologies()) > 0:
        data = data[data['Technology'].isin(input.explore_technologies())]

    if len(input.explore_end_use()) > 0:
        data = data[data['EndUse'].isin(input.explore_end_use())]

    data = data[data['Period'] == input.explore_period()]

    return data
```

<br/>
<h5>Download</h5>

```{python}
@render.ui
def render_explore_download_button():
    btn_class = 'btn-secondary'
    return ui.input_action_button(id="explore_download", label="⭳", class_=btn_class) #icon=icon_svg("download"), 

```

### Column

```{python}
#| content: card-toolbar
# https://github.com/posit-dev/py-shiny/issues/973

@render.ui
def render_bar_button():
    btn_class = 'btn-primary' if explore_chart_type.get() == 'Bar' else 'btn-secondary'
    return ui.input_action_button("explore_bar", "Bar Chart", class_=btn_class)
@reactive.effect
def set_explore_bar_chart():
    input.explore_bar()
    with reactive.isolate():
        explore_chart_type.set('Bar')

@render.ui
def render_sankey_button():
    btn_class = 'btn-primary' if explore_chart_type.get() == 'Sankey' else 'btn-secondary'
    return ui.input_action_button("explore_sankey", "Sankey Chart", class_=btn_class)
@reactive.effect
def set_explore_sankey_chart():
    input.explore_sankey()
    with reactive.isolate():
        explore_chart_type.set('Sankey')

```

```{python}
#| title: Stationary Energy Usage

# Initialize a reactive value
explore_chart_type = reactive.value('Sankey')

@render_widget
def display_explore_chart():
    left_node = title_case(input.explore_left_node())
    right_node = title_case(input.explore_right_node())
    explore_df = explore_eeud_filtered().groupby([left_node, right_node]).sum(numeric_only=True).reset_index(drop=False)

    if explore_chart_type.get() == 'Sankey':
        explore_links, explore_nodes = create_sankey_links_for_dict(explore_df, left_node, right_node)
        fig = go.Figure(data=[go.Sankey(
            node = dict(
                pad = 15,
                thickness = 20,
                line = dict(width = 0),
                label = explore_nodes['label'],
                color = explore_nodes['color']
                ),
            link = dict(
                source = explore_links['source'],
                target = explore_links['target'],
                value = explore_links['value'],
                color = explore_links['color']
                )
        )])
        fig.update_layout(modebar_remove=['zoom', 'pan', 'select', 'lasso', 'zoomin', 'zoomout', 'autoscale', 'resetscale'])
        fig.update_layout(paper_bgcolor='rgba(0,0,0,0)', plot_bgcolor='rgba(0,0,0,0)')
        return fig

    elif explore_chart_type.get() == 'Bar':
        fig = px.bar(explore_df,
            x='TJ', y=left_node, color=right_node, color_discrete_map=eeud_colours.to_dict()
        )
        fig.update_layout(modebar_remove=['zoom', 'pan', 'select', 'lasso', 'zoomin', 'zoomout', 'autoscale', 'resetscale'])
        fig.update_layout(paper_bgcolor='rgba(0,0,0,0)', plot_bgcolor='rgba(0,0,0,0)')
        return fig

``` 


# Chronistic

## Row

### Column {.sidebar}

<h5>Categories</h5>

```{python}
ui.input_select("chronistic_category", "Category", choices=["End Use", "End Use Group", "Fuel", "Fuel Group", "Sector", "Sector Group", "Technology", "Technology Group"], selected="Fuel")
```

<br/>
<h5>Filter</h5>

```{python}

ui.input_selectize('chronistic_sectors', "Sector", sectors_list, multiple=True,
    options={
        'placeholder': "All Sectors",
        'plugins': ['clear_button']
    }
)

ui.input_selectize('chronistic_fuels', "Fuel Type", fuels_list, multiple=True, 
    options={
        'placeholder': "All Fuel Types",
        'plugins': ['clear_button']
    }
)

ui.input_selectize('chronistic_technologies', "Technology", technologies_list, multiple=True,
    options={
        'placeholder': "All Technologies",
        'plugins': ['clear_button']
    }
)

ui.input_selectize('chronistic_end_use', "End Use", end_uses_list, multiple=True,
    options={
        'placeholder': "All End Uses",
        'plugins': ['clear_button']
    }
)

@reactive.Calc
def chronistic_eeud_filtered():
    data = eeud.copy()

    if len(input.chronistic_sectors()) > 0:
        data = data[data['Sector'].isin(input.chronistic_sectors())]

    if len(input.chronistic_fuels()) > 0:
        data = data[data['Fuel'].isin(input.chronistic_fuels())]

    if len(input.chronistic_technologies()) > 0:
        data = data[data['Technology'].isin(input.chronistic_technologies())]

    if len(input.chronistic_end_use()) > 0:
        data = data[data['EndUse'].isin(input.chronistic_end_use())]

    return data
```

<br/>
<h5>Download</h5>

```{python}
@render.ui
def render_chronistic_download_button():
    btn_class = 'btn-secondary'
    return ui.input_action_button(id="chronistic_download", label="⭳", class_=btn_class) #icon=icon_svg("download"), 

```


### Column

```{python}
#| content: card-toolbar

@render.ui
def render_chronistic_area_button():
    btn_class = 'btn-primary' if chronistic_chart_type.get() == 'Area' else 'btn-secondary'
    return ui.input_action_button("chronistic_area", "Area Chart", class_=btn_class)

@render.ui
def render_chronistic_line_button():
    btn_class = 'btn-primary' if chronistic_chart_type.get() == 'Line' else 'btn-secondary'
    return ui.input_action_button("chronistic_line", "Line Chart", class_=btn_class)

@render.ui
def render_chronistic_alluvial_button():
    btn_class = 'btn-primary' if chronistic_chart_type.get() == 'Alluvial' else 'btn-secondary'
    return ui.input_action_button("chronistic_alluvial", "Alluvial Chart", class_=btn_class)


@reactive.effect
def set_chronistic_area_chart():
    input.chronistic_area()
    with reactive.isolate():
        chronistic_chart_type.set('Area')

@reactive.effect
def set_chronistic_line_chart():
    input.chronistic_line()
    with reactive.isolate():
        chronistic_chart_type.set('Line')

@reactive.effect
def set_chronistic_alluvial_chart():
    input.chronistic_alluvial()
    with reactive.isolate():
        chronistic_chart_type.set('Alluvial')

```

```{python}
#| title: Energy Usage Time Series
 
chronistic_chart_type = reactive.value('Line')

@render_widget
def display_chronistic_chart():
    category = title_case(input.chronistic_category())
    chronistic_df = chronistic_eeud_filtered().groupby([category, 'Period']).sum(numeric_only=True).reset_index(drop=False)

    if chronistic_chart_type.get() == 'Alluvial':
        chronistic_links, chronistic_nodes = create_alluvial_links_for_dict(chronistic_eeud_filtered(), category, 'PeriodEndDate')
        fig = go.Figure(data=[go.Sankey(
            node = dict(
                pad = 15,
                thickness = 20,
                line = dict(width = 0),
                label = chronistic_nodes['label'],
                color = chronistic_nodes['color']
                ),
            link = dict(
                source = chronistic_links['source'],
                target = chronistic_links['target'],
                value = chronistic_links['value'],
                color = chronistic_links['color']
                )
        )])
        fig.update_layout(modebar_remove=['zoom', 'pan', 'select', 'lasso', 'zoomin', 'zoomout', 'autoscale', 'resetscale'])
        fig.update_layout(paper_bgcolor='rgba(0,0,0,0)', plot_bgcolor='rgba(0,0,0,0)')
        return fig


    elif chronistic_chart_type.get() == 'Line':
        fig = px.line(chronistic_df,
            y='TJ', x='Period', color=category, color_discrete_map=eeud_colours.to_dict(),
            markers=True).update_xaxes(dtick=1)
        fig.update_layout(modebar_remove=['zoom', 'pan', 'select', 'lasso', 'zoomin', 'zoomout', 'autoscale', 'resetscale'])
        fig.update_layout(paper_bgcolor='rgba(0,0,0,0)', plot_bgcolor='rgba(0,0,0,0)')
        return fig


    elif chronistic_chart_type.get() == 'Area':
        fig = px.area(chronistic_df,
            y='TJ', x='Period', color=category, color_discrete_map=eeud_colours.to_dict(),
            markers=True).update_xaxes(dtick=1)
        fig.update_layout(modebar_remove=['zoom', 'pan', 'select', 'lasso', 'zoomin', 'zoomout', 'autoscale', 'resetscale'])
        fig.update_layout(paper_bgcolor='rgba(0,0,0,0)', plot_bgcolor='rgba(0,0,0,0)')
        return fig


``` 

# Data

## Row

### Column {.sidebar}

<h5>Filter</h5>

```{python}
ui.input_selectize('data_sectors', "Sector", sectors_list, multiple=True,
    options={
        'placeholder': "All Sectors",
        'plugins': ['clear_button']
    }
)

ui.input_selectize('data_fuels', "Fuel Type", fuels_list, multiple=True, 
    options={
        'placeholder': "All Fuel Types",
        'plugins': ['clear_button']
    }
)

ui.input_selectize('data_technologies', "Technology", technologies_list, multiple=True,
    options={
        'placeholder': "All Technologies",
        'plugins': ['clear_button']
    }
) 

ui.input_selectize('data_end_use', "End Use", end_uses_list, multiple=True,
    options={
        'placeholder': "All End Uses",
        'plugins': ['clear_button']
    }
)

ui.input_slider('data_period', "Date Range", min=min(years_list), max=max(years_list),
    drag_range=True, value=(min(years_list), max(years_list)), sep='')


@reactive.Calc
def data_eeud_filtered():
    data = eeud.copy()

    if len(input.data_sectors()) > 0:
        data = data[data['Sector'].isin(input.data_sectors())]

    if len(input.data_fuels()) > 0:
        data = data[data['Fuel'].isin(input.data_fuels())]

    if len(input.data_technologies()) > 0:
        data = data[data['Technology'].isin(input.data_technologies())]

    if len(input.data_end_use()) > 0:
        data = data[data['EndUse'].isin(input.data_end_use())]

    data = data[data['Period'].between(input.data_period()[0], input.data_period()[1], inclusive='both')]

    return data
```

<br/>
<h5>Download</h5>

```{python}
@render.ui
def render_data_download_button():
    btn_class = 'btn-secondary'
    return ui.input_action_button(id="data_download", label="⭳", class_=btn_class) #icon=icon_svg("download"), 

```

### Column


```{python} 
@render.data_frame
def dataview():
    return render.DataGrid(data_eeud_filtered().drop(['SectorANZSIC', 'PeriodEndDate', 'Transport'], axis=1), height="100%", width="100%", summary=False)
``` 

# About

## Row

### Column

::: {.card .borderless .fill}

### **Energy End Use Database (EEUD)**

<br/>

<p>Energy End Use Database (EEUD) is a unique New Zealand data asset maintained by Energy Efficiency and Conservation Authority (EECA) enabling insights and analysis of energy use across sectors and technology by government, industry, and academia.</p>

<p>The EEUD provides annual estimates of how energy is used across the New Zealand economy. Delivered energy estimates are provided for fuel types, sectors, end uses and technologies. The current published data covers years 2017 to 2021. The data is always released for the previous year soon after the MBIE Energy Balances are released.</p>

<p>Energy use estimates are derived using 'top down' approach based on MBIE's annual high-level sector/fuel energy demand data and proportioned into further disaggregated sectors, end use applications and technology values using 'bottom up' data held by EECA.</p>

<h5><b>Sankey Diagram Explanation</b></h5>

The Sankey diagrams shown here display the flow of energy from one group category to another. For instance, the energy flow from the group 'Fuel' to the group 'End Use' shows how different fuel types are used. For instance, 84,808 Terajoules of Electricity is used for Heating/Cooling in 2020. The size of each flow bar on the Sankey diagram is proportional to the volume of energy expressed.

##### **Short guide on categories in the database**

The EEUD is split into four categories – Sector, Fuel Type, End Use, and Technology. Each category has two levels (group level and disaggregated level), as tabled below with examples. The levels are shown in the tool as filter options in the dropdown boxes (i.e., the user can select to view the data by Sector Group, or by Sector for more disaggregation. For complete lists refer to the documentation linked below.

Table Goes Here

##### **Find out more about the Energy End Use Database (EEUD)**

To learn more about the methodology check out the document 'Energy End Use Database (EEUD) - Key insights and methodology'. 

For feedback and more information, please email info@eeca.govt.nz with the subject line 'Energy End Use Database'.

:::

### {.sidebar width=40%}

::: {.card .flow}

##### **Release notes**

**Version 1.2** 

* 2021 data added for all sectors. Released on the 23rd of March 2023.

**Version 1.1**

* Transport data added to the tool, allowing users to split by Vehicle Type, Technology and Fuel Type. For Stationary Energy, Heating/Cooling was split into two separate categories. Released on the 20th of April 2022.

**Version 1.0**

* Initial release of the Energy End Use Database (EEUD) on the 3rd of November 2021.

Keep up to date on new data releases through the EECA Newsletter (sign up here) and check the website frequently for updates.

:::

::: {.card .flow}

(Creative Commons License)

This work is licensed under a Creative Commons Attribution 4.0 New Zealand License.
:::
